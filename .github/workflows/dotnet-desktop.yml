name: .NET Desktop Build

on:
  push:
    branches: [ "main", "master" ]
  pull_request:
    branches: [ "main", "master" ]

permissions:
  contents: write   # allow GITHUB_TOKEN to create tags/releases

jobs:
  build:
    runs-on: windows-latest

    env:
      Solution_Name: ironmanx-04-2.sln
      Project_File: ironmanx-04-2\ironmanx-04-2.csproj
      Project_Directory: ironmanx-04-2
      Configuration: Release
      Platform: x64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      - name: Setup NuGet
        uses: NuGet/setup-nuget@v2

      - name: Restore NuGet packages
        shell: pwsh
        run: |
          if (Test-Path $env:Solution_Name) {
            nuget restore $env:Solution_Name
          } elseif (Test-Path $env:Project_File) {
            nuget restore $env:Project_File
          } else {
            Write-Host "No solution or project found to restore."
          }

      - name: Build solution
        shell: pwsh
        run: |
          if (Test-Path $env:Solution_Name) {
            msbuild $env:Solution_Name /p:Configuration=$env:Configuration /p:Platform=$env:Platform /m
          } else {
            msbuild $env:Project_File /p:Configuration=$env:Configuration /p:Platform=$env:Platform /m
          }

      # --- Inspect bin tree so we can see where the build actually put outputs
      - name: List bin tree (for debugging)
        shell: pwsh
        run: |
          $bin = Join-Path $env:Project_Directory 'bin'
          if (Test-Path $bin) {
            Write-Host "==== BIN TREE ===="
            Get-ChildItem -Recurse $bin | Select-Object FullName,Length,LastWriteTime | Format-Table -AutoSize | Out-String | Write-Host
          } else {
            Write-Host "No bin directory found."
          }

      # --- Extract version (InformationalVersion > AssemblyVersion > run number)
      - name: Get version
        id: get_version
        shell: pwsh
        run: |
          $asmInfo = Join-Path $env:Project_Directory 'Properties\AssemblyInfo.cs'
          $version = $null
          if (Test-Path $asmInfo) {
            $infoMatch = Select-String -Path $asmInfo -Pattern 'AssemblyInformationalVersion\("([^"]+)"\)' | Select-Object -First 1
            if ($infoMatch) { $version = $infoMatch.Matches[0].Groups[1].Value }
            if (-not $version) {
              $verMatch = Select-String -Path $asmInfo -Pattern 'AssemblyVersion\("([0-9\.]+)"\)' | Select-Object -First 1
              if ($verMatch) { $version = $verMatch.Matches[0].Groups[1].Value }
            }
          }
          if (-not $version) { $version = "${{ github.run_number }}" }
          "version=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          Write-Host "Using version: $version"

      # --- Find the EXE anywhere under bin\ (handles bin\Release or bin\x86\Release, etc.)
      #     Zip the folder containing the main EXE; output a newline list of files for the release step
      - name: Collect release files (exe + zip)
        id: collect
        if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && env.Configuration == 'Release'
        shell: pwsh
        run: |
          $bin = Join-Path $env:Project_Directory 'bin'
          if (-not (Test-Path $bin)) {
            throw "No bin directory found at $bin"
          }

          # Prefer exe that matches project name; fallback to any exe under bin
          $projName = [IO.Path]::GetFileNameWithoutExtension($env:Project_File)
          $exe = Get-ChildItem -Path $bin -Recurse -Filter "$projName.exe" | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          if (-not $exe) {
            $exe = Get-ChildItem -Path $bin -Recurse -Filter *.exe | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          }
          if (-not $exe) {
            throw "No .exe found under $bin"
          }
          Write-Host "Selected EXE: $($exe.FullName)"

          # Zip the entire folder containing the exe
          $outDir  = $exe.Directory.FullName
          $zipName = "${projName}_$("${{ steps.get_version.outputs.version }}").zip"
          $zipPath = Join-Path $outDir $zipName
          if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
          Compress-Archive -Path (Join-Path $outDir '*') -DestinationPath $zipPath
          Write-Host "Created ZIP: $zipPath"

          # Prepare newline-delimited list of files for gh-release
          Add-Content $env:GITHUB_OUTPUT "files<<EOF"
          Add-Content $env:GITHUB_OUTPUT $exe.FullName
          Add-Content $env:GITHUB_OUTPUT $zipPath
          Add-Content $env:GITHUB_OUTPUT "EOF"

      # --- Upload the whole output folder as an artifact (nice for debugging too)
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: BuildOutput
          path: ${{ env.Project_Directory }}\bin\

      # --- Create release and upload assets using explicit file list
      - name: Create Release & Upload Assets
        uses: softprops/action-gh-release@v2
        if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && env.Configuration == 'Release'
        with:
          tag_name: v${{ steps.get_version.outputs.version }}
          name: "Release v${{ steps.get_version.outputs.version }}"
          body: |
            ðŸš€ Automated release from GitHub Actions  
            Commit: ${{ github.sha }}  
            Configuration: ${{ env.Configuration }}  
            Platform: ${{ env.Platform }}
          files: ${{ steps.collect.outputs.files }}   # <-- explicit files we just found
          generate_release_notes: true
          make_latest: true
          overwrite_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
